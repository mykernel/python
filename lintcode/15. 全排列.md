给定一个数字列表，返回其所有可能的排列。

你可以假设没有重复数字。


样例
样例 1：

输入：[1]
输出：
[
  [1]
]

样例 2：

输入：[1,2,3]
输出：
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]

挑战
使用递归和非递归分别解决。

```python
def nx(lst):
    x = []
    idx = 1

    for i,v in enumerate(lst):
        x.append(lst[:i][::-1]+lst[i:][::-1])

    print(x)

nx([1,2])
```

    [[2, 1], [1, 2]]



```python

```


```python

```


```python

```


```python
nx([1,2,3])
nx([3,2,1])
```

    [[3, 2, 1], [1, 3, 2], [2, 1, 3]]
    [[1, 2, 3], [3, 1, 2], [2, 3, 1]]



```python
nx([4,3, 2, 1])
nx([4,1, 3, 2])
nx([4,2, 1, 3])
nx([4,1, 2, 3])
nx([4,3, 1, 2])
nx([4,2, 3, 1])
```

    [[1, 2, 3, 4], [4, 1, 2, 3], [3, 4, 1, 2], [2, 3, 4, 1]]
    [[2, 3, 1, 4], [4, 2, 3, 1], [1, 4, 2, 3], [3, 1, 4, 2]]
    [[3, 1, 2, 4], [4, 3, 1, 2], [2, 4, 3, 1], [1, 2, 4, 3]]
    [[3, 2, 1, 4], [4, 3, 2, 1], [1, 4, 3, 2], [2, 1, 4, 3]]
    [[2, 1, 3, 4], [4, 2, 1, 3], [3, 4, 2, 1], [1, 3, 4, 2]]
    [[1, 3, 2, 4], [4, 1, 3, 2], [2, 4, 1, 3], [3, 2, 4, 1]]



```python
def nx(lst):
    x = []
    idx = 1

    for i,v in enumerate(lst):
        x.append(lst[:i][::-1]+lst[i:][::-1])

    print(x)

nx([1,2])
```

    [[2, 1], [1, 2]]



```python

```


```python

```


```python
nx([1])
```

    [[1]]



```python
nx([1,2])
```

    [[2, 1], [1, 2]]



```python
# [1,2,3]
nx([3,2,1])
nx([3,1,2])
```

    [[1, 2, 3], [3, 1, 2], [2, 3, 1]]
    [[2, 1, 3], [3, 2, 1], [1, 3, 2]]



```python
ll = [1,2,3,4,5]
```


```python

```


```python
lst = [1,2,3]
lst.pop()
lst
```




    [1, 2]


