要求：
打印一个完全二叉树

提示：
打印空格、元素和间隔的关系


![二叉树](http://qiniu.mykernel.cn/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%E8%A7%84%E5%BE%8B.png)


```python
lst = [0,30,20,80,40,50,10,60,70,90,110,-12,11,123,21,43]

import math

def print_tree(lst):
    index = 1 
    sep = '   '
    depth = math.ceil(math.log2(len(lst)))   #因为就是补0了
    #print(depth)
    for i in range(depth):
        offset = 2 **i 
        print(sep*(2**(depth - i-1)-1),end = '')
        line = lst[index:index + offset]
        index += offset
        for j,x in enumerate(line):
            print("{:>{}}".format(x,len(sep)),end='')
            interval = 0 if i ==0 else 2 **(depth-i)-1
            if j<len(line) -1 :
                print(sep * interval,end = '')
            
        print('\n') 
        
print_tree(lst)
```

                          30
    
              20                      80
    
        40          50          10          60
    
     70    90   110   -12    11   123    21    43
    



```python
lst = [0,30,20,80,40,50,10,60,70,90,110,-12,11,123,21,43]
import math 

def print_tree1(old_tree):
    index = 1 
    sep = '  '
    dep =math.ceil(math.log2(len(old_tree)))
    
    for i in range(dep):
        offset = 2**i #索引移动
        print(sep*(2**(dep-i-1)-1),end = '')
        line = old_tree[index:index+offset]
        for j,x in enumerate(line):
            print("{:>}".format(x),end='')
            #print("{:>{}}".format(x,len(sep)),end='')
            interval = 0 if i ==0 else 2 **(dep-i)-1
            if j < len(line) -1:
                print(sep*interval,end = '')
        print('\n')
                  
print_tree1(lst)    
```

                  30
    
          30              20
    
      30      20      80      40
    
    30  20  80  40  50  10  60  70
    

