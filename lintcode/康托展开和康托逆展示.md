康托展开举例

在5个数的排列组合中，计算 34152的康托展开值。

首位是3，则小于3的数有两个，为1和2，  ，则首位小于3的所有排列组合为 a[5]=2
第二位是4，由于第一位小于4，1、2、3中一定会有1个充当第一位，所以排在4之下的只剩2个，所以其实计算的是在第二位之后小于4的个数。因此 a[4]=2 。
第三位是1，则在其之后小于1的数有0个，所以  a[3] = 0
第四位是5，则在其之后小于5的数有1个，为2，所以 a[2] = 1
最后一位就不用计算啦，因为在它之后已经没有数了 a[1]=0
根据公式：
  x = 2 * 4! + 2*3! + 0*2! + 1*1! + 0*0!
  = 48+ 12 + 1 + 1 + 0 = 61 
所以比34152小的组合有61个，即34152是排第62。
  
  
在给出61可以算出起排列组合为34152。由上述的计算过程可以容易的逆推回来，具体过程如下：

用 61 / 4! = 2余13，说明  ,说明比首位小的数有2个，所以首位为3。
用 13 / 3! = 2余1，说明  ，说明在第二位之后小于第二位的数有2个，所以第二位为4。
用 1 / 2! = 0余1，说明  ，说明在第三位之后没有小于第三位的数，所以第三位为1。
用 1 / 1! = 1余0，说明  ，说明在第二位之后小于第四位的数有1个，所以第四位为5。
最后一位自然就是剩下的数2。
通过以上分析，所求排列组合为 34152。 
康托展开代码实现
求34152 在全排列中的排序
全排列，1 2 3 4 5 这个5个数字的任意组合，从小到大的组合的排列。
#### 康托展开


```python
def Tony_Show(iterable):

    #l = [10,9,3,2,1]
    count = 0
    fac = []
    ord_sum = 0 
    len_str = len(iterable)
    # 阶乘函数
    def factorial(n):
        num = 1
        for i in range(1, n+1):
            num *= i
        return num

    for i,x in enumerate(iterable):
        for y in iterable[i+1:]:
            #print(x,y)
            if x>y:
                count+=1        
        else:
            fac.append(count)
            count = 0

    for i, v in enumerate(fac):
        #print(int(v*factorial(len_str-i-1)))
        ord_sum += int(v*factorial(len_str-i-1))


    return ord_sum+1

```

#### 康托逆展示


```python
def Tony_Reverse_Show(iterable,num):
    #l = [3,4,1,5,2]
    l_s = sorted(iterable)
    #num  = 61
    c = []
    m = []
    def factorial(n):
        num = 1
        for i in range(1, n+1):
            num *= i
        return num

    for i in range(len(iterable)-1,0,-1):
        a,num = divmod(num,factorial(i))
        c.append(a)

    for x in c:
        m.append(l_s[x])
        l_s.remove(l_s[x])
    m.extend(l_s)
    return m
```

#### 全排列（n<7）


```python
def  all_list(iterable):
    new_lst = []
    lst = []
    
    iterable_sort = sorted(iterable,reverse=True)
    num = Tony_Show(iterable_sort)

    for i in range(num):
        all_lst_tmp = Tony_Reverse_Show(iterable,i)
        lst.append(all_lst_tmp)

    for x in lst:
        if x not in new_lst:
            new_lst.append(x)
    
    print("一共{}种排列".format(len(new_lst)))       
    #print(new_lst)
```


```python
all_list([1,2,3,4,5,6,7])
```

    一共5040种排列



```python
def  all_list_only_print(iterable):
    iterable_sort = sorted(iterable,reverse=True)
    num = Tony_Show(iterable_sort)
    print("一共{}种排列".format(num))
```


```python
all_list_only_print([1,2,3,4,5,6,7,8,9,10,11,12,13,1,2,3,4,54])
```

    一共6402373705722833种排列



```python
lst = ([1, 2, 2],
[1, 2, 2],
[2, 1, 2],
[2, 2, 1])
```


```python
new_lst = []

for x in lst:
    if x not in new_lst:
        new_lst.append(x)
                
            
new_lst         

        for x in all_lst_tmp:
            if x not in new_lst:
                new_lst.append(x)
    
```




    [[1, 2, 2], [2, 1, 2], [2, 2, 1]]




```python

```


```python

```


```python

```


```python

```

#### 草稿



```python
num = 34152
# 阶乘函数
def factorial(n):
    num = 1 
    for i in range(1,n+1):
        num *= i
    return num

str_num = str(num)
lst_num = []
fac_lst = []
ord_sum = 0

for i in str(str_num):
    lst_num.append(int(i))
    

len_str = len(str_num)
#print(len_str)
# 2 2 0 1 0 

for i,v in enumerate(str_num):
    #print(i)
    lst_ord = ''.join(sorted(str_num))
    if (lst_ord.find(v) - i) < 0:
        fac_lst.append(0)
    else:
        fac_lst.append((lst_ord.find(v) - i))
        
for i,v in enumerate(fac_lst):
    ord_sum +=int(v*factorial(len_str-i-1))

    
print(ord_sum)
```

    61

输入:[1,2,4]
输出:1

```python
lst =[10,9,8,7,6,5,4,3,2,1]
num_str = []

for i in lst:
    num_str.append(str(i))

num = int(''.join(num_str))

#num = 34152
# 阶乘函数
def factorial(n):
    num = 1 
    for i in range(1,n+1):
        num *= i
    return num

str_num = str(num)
lst_num = []
fac_lst = []
ord_sum = 0

for i in str(str_num):
    lst_num.append(int(i))
    

len_str = len(str_num)
#print(len_str)
# 2 2 0 1 0 

for i,v in enumerate(str_num):
    
    lst_ord = ''.join(sorted(str_num[i:]))
    fac_lst.append(lst_ord.find(v))
        
for i,v in enumerate(fac_lst):
    ord_sum +=int(v*factorial(len_str-i-1))

    
print(ord_sum+1)
```

    3991680



```python
# 3628800
```


```python
lst =[10,9,8,7,6,5,4,3,2,1]
num_str = []

for i in lst:
    num_str.append(str(i))

num = int(''.join(num_str))
print(num)
#num = 34152
# 阶乘函数
def factorial(n):
    num = 1 
    for i in range(1,n+1):
        num *= i
    return num

str_num = str(num)
lst_num = []
fac_lst = []
ord_sum = 0

for i in str(str_num):
    lst_num.append(int(i))
    
lst_num = [10,9,8,7,6,5,4,3,2,1]
len_str = len(str_num)
#print(len_str)
# 2 2 0 1 0 

for i,v in enumerate(str_num):
    
    lst_ord = ''.join(sorted(str_num[i:]))
    fac_lst.append(lst_ord.find(v))
        
for i,v in enumerate(fac_lst):
    ord_sum +=int(v*factorial(len_str-i-1))

    
print(ord_sum+1)
```

    10987654321
    3991680



```python
new_lst = [10,9,8,7,6,5,4,3,2,1]
new_lst_ord = sorted(new_lst)
```


```python
fac_lst = []
ord_sum = 0

for x in new_lst:
    for j,y in enumerate(new_lst_ord):
        if x == y :
            fac_lst.append(j+1)

print(fac_lst)
for i,v in enumerate(fac_lst):
    ord_sum +=int(v*factorial(len_str-i-1))

    
print(ord_sum+1)
```

    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    39916800



```python
fac_lst
```




    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]




```python

```


```python
def factorial(n):
    num = 1
    for i in range(1, n+1):
        num *= i
    return num


new_lst = [1, 2, 4]
new_lst_ord = sorted(new_lst,reverse=True)
len_str = len(new_lst)

fac_lst = []
ord_sum = 0

for x in new_lst:
    for j, y in enumerate(new_lst_ord):
        if x == y:
            new_lst.remove(y)
            fac_lst.append(j)

            
print(fac_lst)
for i, v in enumerate(fac_lst):
    print(int(v*factorial(len_str-i-1)))
    ord_sum += int(v*factorial(len_str-i-1))
# 3628800

print(ord_sum+1)
```

    [2, 0]
    4
    0
    5



```python
lst = [4,3,8,2]
```


```python
aa = sorted(lst)
aa
```




    [2, 3, 4, 8]




```python
# 阶乘函数
def factorial(n):
    num = 1
    for i in range(1, n+1):
        num *= i
    return num


new_lst = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
new_lst_ord = sorted(new_lst,reverse=True)
print(new_lst)
print(new_lst_ord)
len_str = len(new_lst)

fac_lst = []
ord_sum = 0

for x in new_lst:
    for j, y in enumerate(new_lst_ord):
        if x == y:
            new_lst.remove(y)
            fac_lst.append(j)

            
print(fac_lst)
for i, v in enumerate(fac_lst):
    print(int(v*factorial(len_str-i-1)))
    ord_sum += int(v*factorial(len_str-i-1))
# 3628800

print(ord_sum+1)
```

    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
    [0, 2, 4, 6, 8]
    0
    80640
    20160
    4320
    960
    106081



```python

```
输入：[10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
输出：3628800

```python
# 阶乘函数
def factorial(n):
    num = 1
    for i in range(1, n+1):
        num *= i
    return num

fac_lst = []
ord_sum = 0 

#new_lst = [10, 9, 8, 7, 6, 5, 4, 3, 2, 1]
new_lst = [1,2,4]
new_lst_ord = sorted(new_lst)
#print(new_lst)
#print(new_lst_ord)

for x in new_lst:
    for j, y in enumerate(new_lst_ord):
        if x == y:
            new_lst.remove(y)
            fac_lst.append(j)
            
print(fac_lst)           

for i, v in enumerate(fac_lst):
    #print(int(v*factorial(len_str-i-1)))
    ord_sum += int(v*factorial(len_str-i-1))
# 3628800

print(ord_sum+1)
```

    [0, 2]
    80641



```python

```


```python
l = [10,9,3,2,1]

count = 0
fac = []
ord_sum = 0 
len_str = len(l)
# 阶乘函数
def factorial(n):
    num = 1
    for i in range(1, n+1):
        num *= i
    return num

for i,x in enumerate(l):
    for y in l[i+1:]:
        #print(x,y)
        if x>y:
            count+=1        
    else:
        fac.append(count)
        count = 0
        
for i, v in enumerate(fac):
    #print(int(v*factorial(len_str-i-1)))
    ord_sum += int(v*factorial(len_str-i-1))


print(ord_sum+1)
#print(fac) 
```

    120


托尼逆展示
在给出61可以算出起排列组合为34152。由上述的计算过程可以容易的逆推回来，具体过程如下：

用 61 / 4! = 2余13，说明  ,说明比首位小的数有2个，所以首位为3。
用 13 / 3! = 2余1，说明  ，说明在第二位之后小于第二位的数有2个，所以第二位为4。
用 1 / 2! = 0余1，说明  ，说明在第三位之后没有小于第三位的数，所以第三位为1。
用 1 / 1! = 1余0，说明  ，说明在第二位之后小于第四位的数有1个，所以第四位为5。
最后一位自然就是剩下的数2。
通过以上分析，所求排列组合为 34152。 

```python
#l = [10,9,3,2,1]
l = [3,4,1,5,2]
l_s = sorted(l)
num  = 61
c = []
m = []
def factorial(n):
    num = 1
    for i in range(1, n+1):
        num *= i
    return num

for i in range(len(l)-1,0,-1):
    a,num = divmod(num,factorial(i))
    c.append(a)
       
for x in c:
    m.append(l_s[x])
    l_s.remove(l_s[x])
m.extend(l_s)
    
    
print(m)

```

    [3, 4, 1, 5, 2]



```python
def Tony_Reverse_Show(iterable,num):
    #l = [3,4,1,5,2]
    l_s = sorted(iterable)
    #num  = 61
    c = []
    m = []
    def factorial(n):
        num = 1
        for i in range(1, n+1):
            num *= i
        return num

    for i in range(len(iterable)-1,0,-1):
        a,num = divmod(num,factorial(i))
        c.append(a)

    for x in c:
        m.append(l_s[x])
        l_s.remove(l_s[x])
    m.extend(l_s)
    return m


def Tony_Show(iterable):

    #l = [10,9,3,2,1]
    count = 0
    fac = []
    ord_sum = 0 
    len_str = len(iterable)
    # 阶乘函数
    def factorial(n):
        num = 1
        for i in range(1, n+1):
            num *= i
        return num

    for i,x in enumerate(iterable):
        for y in iterable[i+1:]:
            #print(x,y)
            if x>y:
                count+=1        
        else:
            fac.append(count)
            count = 0

    for i, v in enumerate(fac):
        #print(int(v*factorial(len_str-i-1)))
        ord_sum += int(v*factorial(len_str-i-1))


    return ord_sum+1

```


```python
Tony_Reverse_Show([1,2,3,4,5],61)
```




    [3, 4, 1, 5, 2]




```python
for i in 
```


```python
Tony_Show([3,2,1])
```

    6


求全排列



```python
num = Tony_Show([5,4,3,2,1])

for i in range(num):
    print(Tony_Reverse_Show([1,2,3,4,5],i))
```

    [1, 2, 3, 4, 5]
    [1, 2, 3, 5, 4]
    [1, 2, 4, 3, 5]
    [1, 2, 4, 5, 3]
    [1, 2, 5, 3, 4]
    [1, 2, 5, 4, 3]
    [1, 3, 2, 4, 5]
    [1, 3, 2, 5, 4]
    [1, 3, 4, 2, 5]
    [1, 3, 4, 5, 2]
    [1, 3, 5, 2, 4]
    [1, 3, 5, 4, 2]
    [1, 4, 2, 3, 5]
    [1, 4, 2, 5, 3]
    [1, 4, 3, 2, 5]
    [1, 4, 3, 5, 2]
    [1, 4, 5, 2, 3]
    [1, 4, 5, 3, 2]
    [1, 5, 2, 3, 4]
    [1, 5, 2, 4, 3]
    [1, 5, 3, 2, 4]
    [1, 5, 3, 4, 2]
    [1, 5, 4, 2, 3]
    [1, 5, 4, 3, 2]
    [2, 1, 3, 4, 5]
    [2, 1, 3, 5, 4]
    [2, 1, 4, 3, 5]
    [2, 1, 4, 5, 3]
    [2, 1, 5, 3, 4]
    [2, 1, 5, 4, 3]
    [2, 3, 1, 4, 5]
    [2, 3, 1, 5, 4]
    [2, 3, 4, 1, 5]
    [2, 3, 4, 5, 1]
    [2, 3, 5, 1, 4]
    [2, 3, 5, 4, 1]
    [2, 4, 1, 3, 5]
    [2, 4, 1, 5, 3]
    [2, 4, 3, 1, 5]
    [2, 4, 3, 5, 1]
    [2, 4, 5, 1, 3]
    [2, 4, 5, 3, 1]
    [2, 5, 1, 3, 4]
    [2, 5, 1, 4, 3]
    [2, 5, 3, 1, 4]
    [2, 5, 3, 4, 1]
    [2, 5, 4, 1, 3]
    [2, 5, 4, 3, 1]
    [3, 1, 2, 4, 5]
    [3, 1, 2, 5, 4]
    [3, 1, 4, 2, 5]
    [3, 1, 4, 5, 2]
    [3, 1, 5, 2, 4]
    [3, 1, 5, 4, 2]
    [3, 2, 1, 4, 5]
    [3, 2, 1, 5, 4]
    [3, 2, 4, 1, 5]
    [3, 2, 4, 5, 1]
    [3, 2, 5, 1, 4]
    [3, 2, 5, 4, 1]
    [3, 4, 1, 2, 5]
    [3, 4, 1, 5, 2]
    [3, 4, 2, 1, 5]
    [3, 4, 2, 5, 1]
    [3, 4, 5, 1, 2]
    [3, 4, 5, 2, 1]
    [3, 5, 1, 2, 4]
    [3, 5, 1, 4, 2]
    [3, 5, 2, 1, 4]
    [3, 5, 2, 4, 1]
    [3, 5, 4, 1, 2]
    [3, 5, 4, 2, 1]
    [4, 1, 2, 3, 5]
    [4, 1, 2, 5, 3]
    [4, 1, 3, 2, 5]
    [4, 1, 3, 5, 2]
    [4, 1, 5, 2, 3]
    [4, 1, 5, 3, 2]
    [4, 2, 1, 3, 5]
    [4, 2, 1, 5, 3]
    [4, 2, 3, 1, 5]
    [4, 2, 3, 5, 1]
    [4, 2, 5, 1, 3]
    [4, 2, 5, 3, 1]
    [4, 3, 1, 2, 5]
    [4, 3, 1, 5, 2]
    [4, 3, 2, 1, 5]
    [4, 3, 2, 5, 1]
    [4, 3, 5, 1, 2]
    [4, 3, 5, 2, 1]
    [4, 5, 1, 2, 3]
    [4, 5, 1, 3, 2]
    [4, 5, 2, 1, 3]
    [4, 5, 2, 3, 1]
    [4, 5, 3, 1, 2]
    [4, 5, 3, 2, 1]
    [5, 1, 2, 3, 4]
    [5, 1, 2, 4, 3]
    [5, 1, 3, 2, 4]
    [5, 1, 3, 4, 2]
    [5, 1, 4, 2, 3]
    [5, 1, 4, 3, 2]
    [5, 2, 1, 3, 4]
    [5, 2, 1, 4, 3]
    [5, 2, 3, 1, 4]
    [5, 2, 3, 4, 1]
    [5, 2, 4, 1, 3]
    [5, 2, 4, 3, 1]
    [5, 3, 1, 2, 4]
    [5, 3, 1, 4, 2]
    [5, 3, 2, 1, 4]
    [5, 3, 2, 4, 1]
    [5, 3, 4, 1, 2]
    [5, 3, 4, 2, 1]
    [5, 4, 1, 2, 3]
    [5, 4, 1, 3, 2]
    [5, 4, 2, 1, 3]
    [5, 4, 2, 3, 1]
    [5, 4, 3, 1, 2]
    [5, 4, 3, 2, 1]



```python

```


```python

```


```python

```


```python

```


```python

```


```python

```
